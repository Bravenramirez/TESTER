using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

public class Strategy
{
    // Properties for CCI, MACD indicators, thresholds, operators, and ATR-based settings
    public required string CciIndicator1 { get; set; }
    public required string CciIndicator2 { get; set; }
    public required string MacdIndicator1 { get; set; }
    public required string MacdIndicator2 { get; set; }
    public required string AtrIndicator { get; set; }
    public double Cci1Threshold { get; set; }
    public double Cci2Threshold { get; set; }
    public double Macd1Threshold { get; set; }
    public double Macd2Threshold { get; set; }
    public required string Cci1Operator { get; set; }
    public required string Cci2Operator { get; set; }
    public required string Macd1Operator { get; set; }
    public required string Macd2Operator { get; set; }
    public double TrailStopMultiplier { get; set; }
    public double ProfitTargetMultiplier { get; set; }
}

public class DefaultSettings
{
    // Define eight default strategies with specific conditions for above and below EMA
    public Strategy AboveEmaLong1 { get; set; }
    public Strategy AboveEmaLong2 { get; set; }
    public Strategy AboveEmaShort1 { get; set; }
    public Strategy AboveEmaShort2 { get; set; }
    public Strategy BelowEmaLong1 { get; set; }
    public Strategy BelowEmaLong2 { get; set; }
    public Strategy BelowEmaShort1 { get; set; }
    public Strategy BelowEmaShort2 { get; set; }

    public DefaultSettings()
    {
        // Initialize each strategy with basic default settings, to be randomized later in optimization
        AboveEmaLong1 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = 100,
            Cci2Threshold = 100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = ">",
            Cci2Operator = ">",
            Macd1Operator = ">",
            Macd2Operator = ">",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        AboveEmaLong2 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = 100,
            Cci2Threshold = 100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = ">",
            Cci2Operator = ">",
            Macd1Operator = ">",
            Macd2Operator = ">",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        AboveEmaShort1 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = -100,
            Cci2Threshold = -100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = "<",
            Cci2Operator = "<",
            Macd1Operator = "<",
            Macd2Operator = "<",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        AboveEmaShort2 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = -100,
            Cci2Threshold = -100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = "<",
            Cci2Operator = "<",
            Macd1Operator = "<",
            Macd2Operator = "<",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        BelowEmaLong1 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = 100,
            Cci2Threshold = 100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = ">",
            Cci2Operator = ">",
            Macd1Operator = ">",
            Macd2Operator = ">",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        BelowEmaLong2 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = 100,
            Cci2Threshold = 100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = ">",
            Cci2Operator = ">",
            Macd1Operator = ">",
            Macd2Operator = ">",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        BelowEmaShort1 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = -100,
            Cci2Threshold = -100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = "<",
            Cci2Operator = "<",
            Macd1Operator = "<",
            Macd2Operator = "<",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };

        BelowEmaShort2 = new Strategy
        {
            CciIndicator1 = "CCI_50",
            CciIndicator2 = "CCI_100",
            MacdIndicator1 = "MACD_12_26",
            MacdIndicator2 = "MACD_9_18",
            AtrIndicator = "ATR_14",
            Cci1Threshold = -100,
            Cci2Threshold = -100,
            Macd1Threshold = 0,
            Macd2Threshold = 0,
            Cci1Operator = "<",
            Cci2Operator = "<",
            Macd1Operator = "<",
            Macd2Operator = "<",
            TrailStopMultiplier = 2.0,
            ProfitTargetMultiplier = 3.0
        };
    }
}

public class SimpleDailyBacktest
{
    public static void Main()
    {
        // Load default settings and prompt user for optimization mode
        var defaults = new DefaultSettings();
        Console.WriteLine("Use default settings? (YES/NO):");
        bool useDefaults = Console.ReadLine()?.Trim().ToUpper() == "YES";

        // Load data and parse indicators from CSV file (BacktestData.csv)
        string[] headers = File.ReadLines("BacktestData.csv").First().Split(',');
        var data = LoadData("BacktestData.csv", headers);

        // Run backtest either in default mode or optimization mode
        RunBacktest(useDefaults, defaults, headers, data);

        Console.WriteLine("Press any key to exit...");
        Console.ReadKey();
    }

    private static List<string[]> LoadData(string filePath, string[] headers)
    {
        var data = new List<string[]>();

        // Read all lines from the CSV file
        var lines = File.ReadAllLines(filePath);

        // Skip the header line (already parsed)
        foreach (var line in lines.Skip(1))
        {
            // Split each line by comma
            var values = line.Split(',');

            // Create a dictionary to store the parsed indicators
            var indicators = new Dictionary<string, double>();

            // Parse each required indicator and add to the dictionary
            for (int i = 0; i < headers.Length; i++)
            {
                string header = headers[i];
                if (header == "CCI" || header == "MACD" || header == "ATR" || header == "EMA200")
                {
                    indicators[header] = double.Parse(values[i], CultureInfo.InvariantCulture);
                }
            }

            // Add the parsed values to the data list
            data.Add(values);
        }

        return data;
    }

    private static void RunBacktest(bool useDefaults, DefaultSettings defaults, string[] headers, List<string[]> data)
    {
        // Main loop to execute each strategy using randomized settings if in optimization mode
        if (useDefaults)
        {
            // Run single backtest with predefined default settings
            PerformBacktest(data, defaults);
        }
        else
        {
            // Run optimization mode, continuously generate and test random strategies
            RunOptimization(data, headers, defaults);
        }
    }

    private static double PerformBacktest(List<string[]> data, DefaultSettings settings)
    {
        var openTrades = new Dictionary<DateTime, (double EntryPrice, string PositionType, double TrailStop, double TargetProfit)>();
        var closedTrades = new Dictionary<DateTime, (double EntryPrice, double ExitPrice, string PositionType)>();

        foreach (var line in data)
        {
            var dateTime = DateTime.Parse(line[0], CultureInfo.InvariantCulture);
            var closePrice = double.Parse(line[1], CultureInfo.InvariantCulture);
            var atrValue = double.Parse(line[2], CultureInfo.InvariantCulture);

            var indicators = new Dictionary<string, double>
        {
            { "CCI20", double.Parse(line[3], CultureInfo.InvariantCulture) },
            { "CCI50", double.Parse(line[4], CultureInfo.InvariantCulture) },
            { "MACD_12_26_9", double.Parse(line[5], CultureInfo.InvariantCulture) },
            { "MACD_19_39_9", double.Parse(line[6], CultureInfo.InvariantCulture) },
            { "EMA200", double.Parse(line[7], CultureInfo.InvariantCulture) }
        };

            // Execute strategies above EMA200
            if (indicators["EMA200"] < closePrice)
            {
                ApplyStrategy(settings.AboveEmaLong1, dateTime, closePrice, atrValue, indicators, openTrades, "Long");
                ApplyStrategy(settings.AboveEmaLong2, dateTime, closePrice, atrValue, indicators, openTrades, "Long");
                ApplyStrategy(settings.AboveEmaShort1, dateTime, closePrice, atrValue, indicators, openTrades, "Short");
                ApplyStrategy(settings.AboveEmaShort2, dateTime, closePrice, atrValue, indicators, openTrades, "Short");
            }
            // Execute strategies below EMA200
            else
            {
                ApplyStrategy(settings.BelowEmaLong1, dateTime, closePrice, atrValue, indicators, openTrades, "Long");
                ApplyStrategy(settings.BelowEmaLong2, dateTime, closePrice, atrValue, indicators, openTrades, "Long");
                ApplyStrategy(settings.BelowEmaShort1, dateTime, closePrice, atrValue, indicators, openTrades, "Short");
                ApplyStrategy(settings.BelowEmaShort2, dateTime, closePrice, atrValue, indicators, openTrades, "Short");
            }

            // Manage exits for open trades
            ManageExits(openTrades, dateTime, closePrice, atrValue);

            // Move closed trades to closedTrades dictionary
            foreach (var trade in openTrades.Where(t => t.Value.TrailStop == 0 && t.Value.TargetProfit == 0).ToList())
            {
                closedTrades[trade.Key] = (trade.Value.EntryPrice, closePrice, trade.Value.PositionType);
                openTrades.Remove(trade.Key);
            }
        }

        // Calculate and return the total profit
        return CalculateResults(closedTrades);
    }

    private static void ApplyStrategy(Strategy strategy, DateTime dateTime, double closePrice, double atrValue, Dictionary<string, double> indicators, Dictionary<DateTime, (double EntryPrice, string PositionType, double TrailStop, double TargetProfit)> openTrades, string positionType)
    {
        if (CheckEntryConditions(strategy, indicators) && dateTime.TimeOfDay == new TimeSpan(9, 30, 0))
        {
            var entryPrice = closePrice;
            var trailStop = closePrice - atrValue * strategy.TrailStopMultiplier;
            var targetProfit = closePrice + atrValue * strategy.ProfitTargetMultiplier;

            if (positionType == "Short")
            {
                trailStop = closePrice + atrValue * strategy.TrailStopMultiplier;
                targetProfit = closePrice - atrValue * strategy.ProfitTargetMultiplier;
            }

            openTrades[dateTime] = (entryPrice, positionType, trailStop, targetProfit);
            LogTrade(dateTime, dateTime, entryPrice, entryPrice, positionType, 0);
        }
    }

    private static void RunOptimization(List<string[]> data, string[] headers, DefaultSettings defaults)
    {
        // Optimization loop to generate random strategies until interrupted
        var bestProfit = double.MinValue;
        var bestSettings = new DefaultSettings();

        Console.WriteLine("Optimization running. Press any key to stop...");

        while (!Console.KeyAvailable)
        {
            // Generate randomized settings for each strategy
            RandomizeStrategySettings(defaults);

            // Run the backtest with the new randomized settings
            var result = PerformBacktest(data, defaults); // Ensure PerformBacktest returns a double

            Console.WriteLine($"Current Profit: {result}");

            // If profit improves, save new best settings
            if (result > bestProfit)
            {
                bestProfit = result;
                bestSettings = new DefaultSettings
                {
                    AboveEmaLong1 = defaults.AboveEmaLong1,
                    AboveEmaLong2 = defaults.AboveEmaLong2,
                    AboveEmaShort1 = defaults.AboveEmaShort1,
                    AboveEmaShort2 = defaults.AboveEmaShort2,
                    BelowEmaLong1 = defaults.BelowEmaLong1,
                    BelowEmaLong2 = defaults.BelowEmaLong2,
                    BelowEmaShort1 = defaults.BelowEmaShort1,
                    BelowEmaShort2 = defaults.BelowEmaShort2
                };

                Console.WriteLine("New Best Profit Found!");
            }
        }

        Console.WriteLine($"Best Profit: {bestProfit}");
        // On exit, output best settings and save to file
        SaveBestStrategySettings(bestSettings);
    }

    private static void RandomizeStrategySettings(DefaultSettings settings)
    {
        var random = new Random();

        // Define possible values for randomization
        string[] cciIndicators = { "CCI_50", "CCI_100", "CCI_200" };
        string[] macdIndicators = { "MACD_12_26", "MACD_9_18", "MACD_24_52" };
        string[] operators = { ">", "<" };
        double[] atrMultipliers = { 1.5, 2.0, 2.5, 3.0 };

        // Randomize settings for all strategies
        var strategies = new[]
        {
        settings.AboveEmaLong1, settings.AboveEmaLong2, settings.AboveEmaShort1, settings.AboveEmaShort2,
        settings.BelowEmaLong1, settings.BelowEmaLong2, settings.BelowEmaShort1, settings.BelowEmaShort2
    };

        foreach (var strategy in strategies)
        {
            strategy.CciIndicator1 = cciIndicators[random.Next(cciIndicators.Length)];
            strategy.CciIndicator2 = cciIndicators[random.Next(cciIndicators.Length)];
            strategy.MacdIndicator1 = macdIndicators[random.Next(macdIndicators.Length)];
            strategy.MacdIndicator2 = macdIndicators[random.Next(macdIndicators.Length)];
            strategy.Cci1Operator = operators[random.Next(operators.Length)];
            strategy.Cci2Operator = operators[random.Next(operators.Length)];
            strategy.Macd1Operator = operators[random.Next(operators.Length)];
            strategy.Macd2Operator = operators[random.Next(operators.Length)];
            strategy.TrailStopMultiplier = atrMultipliers[random.Next(atrMultipliers.Length)];
            strategy.ProfitTargetMultiplier = atrMultipliers[random.Next(atrMultipliers.Length)];
        }
    }

    private static bool CheckEntryConditions(Strategy strategy, Dictionary<string, double> indicators)
    {
        bool cci1Condition = EvaluateCondition(indicators[strategy.CciIndicator1], strategy.Cci1Threshold, strategy.Cci1Operator);
        bool cci2Condition = EvaluateCondition(indicators[strategy.CciIndicator2], strategy.Cci2Threshold, strategy.Cci2Operator);
        bool macd1Condition = EvaluateCondition(indicators[strategy.MacdIndicator1], strategy.Macd1Threshold, strategy.Macd1Operator);
        bool macd2Condition = EvaluateCondition(indicators[strategy.MacdIndicator2], strategy.Macd2Threshold, strategy.Macd2Operator);

        return cci1Condition && cci2Condition && macd1Condition && macd2Condition;
    }

    private static bool EvaluateCondition(double indicatorValue, double threshold, string op)
    {
        return op switch
        {
            ">" => indicatorValue > threshold,
            "<" => indicatorValue < threshold,
            ">=" => indicatorValue >= threshold,
            "<=" => indicatorValue <= threshold,
            "==" => indicatorValue == threshold,
            "!=" => indicatorValue != threshold,
            _ => throw new ArgumentException($"Invalid operator: {op}")
        };
    }

    private static void ManageExits(Dictionary<DateTime, (double EntryPrice, string PositionType, double TrailStop, double TargetProfit)> openTrades, DateTime dateTime, double closePrice, double atrValue)
    {
        var exitTime = new TimeSpan(15, 55, 0); // 3:55 PM

        foreach (var trade in openTrades.ToList())
        {
            var (entryPrice, positionType, trailStop, targetProfit) = trade.Value;

            bool exitConditionMet = positionType switch
            {
                "Long" => closePrice <= trailStop || closePrice >= targetProfit,
                "Short" => closePrice >= trailStop || closePrice <= targetProfit,
                _ => false
            };

            if (exitConditionMet || dateTime.TimeOfDay >= exitTime)
            {
                double exitPrice = closePrice;
                double profit = positionType == "Long" ? exitPrice - entryPrice : entryPrice - exitPrice;
                LogTrade(trade.Key, dateTime, entryPrice, exitPrice, positionType, profit);
                openTrades.Remove(trade.Key);
            }
        }
    }

    private static void LogTrade(DateTime entryDate, DateTime exitDate, double entryPrice, double exitPrice, string positionType, double profit)
    {
        string logFilePath = "TradeLog.txt";
        string logEntry = $"{entryDate:yyyy-MM-dd HH:mm:ss},{exitDate:yyyy-MM-dd HH:mm:ss},{entryPrice:F2},{exitPrice:F2},{positionType},{profit:F2}";

        using (StreamWriter writer = new StreamWriter(logFilePath, true))
        {
            writer.WriteLine(logEntry);
        }
    }

    private static double CalculateResults(Dictionary<DateTime, (double EntryPrice, double ExitPrice, string PositionType)> trades)
    {
        double totalProfit = 0;
        var dailyProfits = new Dictionary<DateTime, double>();
        var weeklyProfits = new Dictionary<int, double>();
        var monthlyProfits = new Dictionary<string, double>();

        foreach (var trade in trades)
        {
            DateTime entryDate = trade.Key;
            DateTime exitDate = entryDate; // Assuming exitDate is the same as entryDate for simplicity
            double profit = trade.Value.PositionType == "Long" ? trade.Value.ExitPrice - trade.Value.EntryPrice : trade.Value.EntryPrice - trade.Value.ExitPrice;

            // Calculate total profit
            totalProfit += profit;

            // Calculate daily profits
            if (!dailyProfits.ContainsKey(entryDate.Date))
            {
                dailyProfits[entryDate.Date] = 0;
            }
            dailyProfits[entryDate.Date] += profit;

            // Calculate weekly profits
            int weekOfYear = CultureInfo.InvariantCulture.Calendar.GetWeekOfYear(entryDate, CalendarWeekRule.FirstFourDayWeek, DayOfWeek.Monday);
            if (!weeklyProfits.ContainsKey(weekOfYear))
            {
                weeklyProfits[weekOfYear] = 0;
            }
            weeklyProfits[weekOfYear] += profit;

            // Calculate monthly profits
            string monthYear = entryDate.ToString("yyyy-MM");
            if (!monthlyProfits.ContainsKey(monthYear))
            {
                monthlyProfits[monthYear] = 0;
            }
            monthlyProfits[monthYear] += profit;
        }

        // Log summary statistics
        Console.WriteLine("Total Profit: " + totalProfit);
        Console.WriteLine("Daily Profits: " + string.Join(", ", dailyProfits.Select(kvp => $"{kvp.Key:yyyy-MM-dd}: {kvp.Value:F2}")));
        Console.WriteLine("Weekly Profits: " + string.Join(", ", weeklyProfits.Select(kvp => $"Week {kvp.Key}: {kvp.Value:F2}")));
        Console.WriteLine("Monthly Profits: " + string.Join(", ", monthlyProfits.Select(kvp => $"{kvp.Key}: {kvp.Value:F2}")));

        return totalProfit;
    }

    private static void GenerateSummary(Dictionary<DateTime, (double EntryPrice, double ExitPrice, string PositionType)> trades)
    {
        int totalTrades = trades.Count;
        int winningTrades = trades.Count(t => (t.Value.PositionType == "Long" && t.Value.ExitPrice > t.Value.EntryPrice) || (t.Value.PositionType == "Short" && t.Value.ExitPrice < t.Value.EntryPrice));
        int losingTrades = totalTrades - winningTrades;
        double winRate = (double)winningTrades / totalTrades * 100;
        double totalProfit = trades.Sum(t => (t.Value.PositionType == "Long" ? t.Value.ExitPrice - t.Value.EntryPrice : t.Value.EntryPrice - t.Value.ExitPrice));

        var dailyProfits = new Dictionary<DateTime, double>();
        var weeklyProfits = new Dictionary<int, double>();
        var monthlyProfits = new Dictionary<string, double>();

        foreach (var trade in trades)
        {
            DateTime entryDate = trade.Key;
            double profit = trade.Value.PositionType == "Long" ? trade.Value.ExitPrice - trade.Value.EntryPrice : trade.Value.EntryPrice - trade.Value.ExitPrice;

            // Calculate daily profits
            if (!dailyProfits.ContainsKey(entryDate.Date))
            {
                dailyProfits[entryDate.Date] = 0;
            }
            dailyProfits[entryDate.Date] += profit;

            // Calculate weekly profits
            int weekOfYear = CultureInfo.InvariantCulture.Calendar.GetWeekOfYear(entryDate, CalendarWeekRule.FirstFourDayWeek, DayOfWeek.Monday);
            if (!weeklyProfits.ContainsKey(weekOfYear))
            {
                weeklyProfits[weekOfYear] = 0;
            }
            weeklyProfits[weekOfYear] += profit;

            // Calculate monthly profits
            string monthYear = entryDate.ToString("yyyy-MM");
            if (!monthlyProfits.ContainsKey(monthYear))
            {
                monthlyProfits[monthYear] = 0;
            }
            monthlyProfits[monthYear] += profit;
        }

        int profitableWeeks = weeklyProfits.Count(wp => wp.Value > 0);
        int totalWeeks = weeklyProfits.Count;
        double profitableWeeksPercentage = (double)profitableWeeks / totalWeeks * 100;

        int profitableMonths = monthlyProfits.Count(mp => mp.Value > 0);
        int totalMonths = monthlyProfits.Count;
        double profitableMonthsPercentage = (double)profitableMonths / totalMonths * 100;

        Console.WriteLine("Performance Summary:");
        Console.WriteLine($"Total Trades: {totalTrades}");
        Console.WriteLine($"Winning Trades: {winningTrades}");
        Console.WriteLine($"Losing Trades: {losingTrades}");
        Console.WriteLine($"Win Rate: {winRate:F2}%");
        Console.WriteLine($"Total Profit: {totalProfit:F2}");

        Console.WriteLine("\nDaily Profits:");
        foreach (var dp in dailyProfits)
        {
            Console.WriteLine($"{dp.Key:yyyy-MM-dd}: {dp.Value:F2}");
        }

        Console.WriteLine("\nWeekly Profits:");
        foreach (var wp in weeklyProfits)
        {
            Console.WriteLine($"Week {wp.Key}: {wp.Value:F2}");
        }
        Console.WriteLine($"Profitable Weeks: {profitableWeeks} out of {totalWeeks} ({profitableWeeksPercentage:F2}%)");

        Console.WriteLine("\nMonthly Profits:");
        foreach (var mp in monthlyProfits)
        {
            Console.WriteLine($"{mp.Key}: {mp.Value:F2}");
        }
        Console.WriteLine($"Profitable Months: {profitableMonths} out of {totalMonths} ({profitableMonthsPercentage:F2}%)");
    }

    private static void SaveBestStrategySettings(DefaultSettings bestSettings)
    {
        using (StreamWriter writer = new StreamWriter("BestStrategySettings.txt"))
        {
            writer.WriteLine("Best Strategy Settings:");

            var strategies = new Dictionary<string, Strategy>
        {
            { "AboveEmaLong1", bestSettings.AboveEmaLong1 },
            { "AboveEmaLong2", bestSettings.AboveEmaLong2 },
            { "AboveEmaShort1", bestSettings.AboveEmaShort1 },
            { "AboveEmaShort2", bestSettings.AboveEmaShort2 },
            { "BelowEmaLong1", bestSettings.BelowEmaLong1 },
            { "BelowEmaLong2", bestSettings.BelowEmaLong2 },
            { "BelowEmaShort1", bestSettings.BelowEmaShort1 },
            { "BelowEmaShort2", bestSettings.BelowEmaShort2 }
        };

            foreach (var strategyPair in strategies)
            {
                writer.WriteLine($"Strategy: {strategyPair.Key}");
                var strategy = strategyPair.Value;
                writer.WriteLine($"CCI Indicator 1: {strategy.CciIndicator1}");
                writer.WriteLine($"CCI Indicator 2: {strategy.CciIndicator2}");
                writer.WriteLine($"MACD Indicator 1: {strategy.MacdIndicator1}");
                writer.WriteLine($"MACD Indicator 2: {strategy.MacdIndicator2}");
                writer.WriteLine($"ATR Indicator: {strategy.AtrIndicator}");
                writer.WriteLine($"CCI 1 Threshold: {strategy.Cci1Threshold}");
                writer.WriteLine($"CCI 2 Threshold: {strategy.Cci2Threshold}");
                writer.WriteLine($"MACD 1 Threshold: {strategy.Macd1Threshold}");
                writer.WriteLine($"MACD 2 Threshold: {strategy.Macd2Threshold}");
                writer.WriteLine($"CCI 1 Operator: {strategy.Cci1Operator}");
                writer.WriteLine($"CCI 2 Operator: {strategy.Cci2Operator}");
                writer.WriteLine($"MACD 1 Operator: {strategy.Macd1Operator}");
                writer.WriteLine($"MACD 2 Operator: {strategy.Macd2Operator}");
                writer.WriteLine($"Trail Stop Multiplier: {strategy.TrailStopMultiplier}");
                writer.WriteLine($"Profit Target Multiplier: {strategy.ProfitTargetMultiplier}");
                writer.WriteLine();
            }
        }
    }
}